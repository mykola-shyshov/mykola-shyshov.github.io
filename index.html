<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
        }

        #gameContainer {
            position: relative;
        }

        #gameCanvas {
            background-color: #000;
            border: 2px solid #333;
        }

        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
        }

        #lives {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 20px;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        #gameTitle {
            font-size: 48px;
            margin-bottom: 20px;
            color: #0095DD;
        }

        #startButton {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #0095DD;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }

        #startButton:hover {
            background-color: #0077aa;
        }

        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        #gameOverText {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff0000;
        }

        #finalScore {
            font-size: 24px;
            margin-bottom: 20px;
        }

        .game-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #0095DD;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }

        .game-button:hover {
            background-color: #0077aa;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="score">Очки: 0</div>
        <div id="lives">Життя: 3</div>
        
        <div id="startScreen">
            <h1 id="gameTitle">Breakout</h1>
            <button id="startButton" class="game-button">Почати гру</button>
        </div>

        <div id="gameOverScreen">
            <h1 id="gameOverText">Гра закінчена!</h1>
            <div id="finalScore">Ваш рахунок: 0</div>
            <button id="restartButton" class="game-button">Грати знову</button>
        </div>
    </div>

    <script>
        // Отримуємо посилання на canvas та його контекст
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');

        // Клас для звуків
        class SoundManager {
            constructor() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.isMusicPlaying = false;
                this.musicGainNode = null;
            }

            play(soundName) {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // Налаштування звуку в залежності від типу
                switch(soundName) {
                    case 'hit':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.1);
                        break;

                    case 'break':
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(880, this.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.2);
                        break;

                    case 'bonus':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(660, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(880, this.audioContext.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.2);
                        break;

                    case 'gameOver':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(220, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(110, this.audioContext.currentTime + 0.5);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.5);
                        break;

                    case 'win':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(880, this.audioContext.currentTime + 0.3);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.3);
                        break;
                }
            }

            // Метод для створення ноти
            createNote(frequency, startTime, duration, type = 'sine') {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, startTime);
                
                gainNode.gain.setValueAtTime(0.1, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + duration);
            }

            // Метод для відтворення фонової музики
            playBackgroundMusic() {
                if (this.isMusicPlaying) return;
                
                this.isMusicPlaying = true;
                this.musicGainNode = this.audioContext.createGain();
                this.musicGainNode.connect(this.audioContext.destination);
                this.musicGainNode.gain.setValueAtTime(0.05, this.audioContext.currentTime);

                // Акорди для фонової музики
                const chords = [
                    [261.63, 329.63, 392.00], // C4, E4, G4
                    [293.66, 349.23, 440.00], // D4, F4, A4
                    [329.63, 392.00, 493.88], // E4, G4, B4
                    [349.23, 440.00, 523.25]  // F4, A4, C5
                ];

                let currentTime = this.audioContext.currentTime;
                const chordDuration = 2; // тривалість акорду в секундах

                const playChord = () => {
                    if (!this.isMusicPlaying) return;

                    const chord = chords[Math.floor(Math.random() * chords.length)];
                    chord.forEach(frequency => {
                        this.createNote(frequency, currentTime, chordDuration);
                    });

                    currentTime += chordDuration;
                    setTimeout(playChord, chordDuration * 1000);
                };

                playChord();
            }

            // Метод для зупинки фонової музики
            stopBackgroundMusic() {
                this.isMusicPlaying = false;
                if (this.musicGainNode) {
                    this.musicGainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                }
            }
        }

        // Клас для бонусів
        class Bonus {
            constructor(game, x, y, type) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.type = type; // 'life', 'speed', 'size'
                this.speed = 2;
                this.active = true;
            }

            update() {
                this.y += this.speed;
                if (this.y > this.game.height) {
                    this.active = false;
                }

                // Перевірка зіткнення з платформою
                if (this.y + this.height > this.game.paddle.y &&
                    this.x + this.width > this.game.paddle.x &&
                    this.x < this.game.paddle.x + this.game.paddle.width) {
                    this.applyBonus();
                    this.active = false;
                }
            }

            draw() {
                if (this.active) {
                    this.game.ctx.fillStyle = this.getColor();
                    this.game.ctx.beginPath();
                    this.game.ctx.arc(this.x + this.width/2, this.y + this.height/2, 
                                    this.width/2, 0, Math.PI * 2);
                    this.game.ctx.fill();
                }
            }

            getColor() {
                switch(this.type) {
                    case 'life': return '#ff0000';
                    case 'speed': return '#00ff00';
                    case 'size': return '#0000ff';
                    default: return '#ffffff';
                }
            }

            applyBonus() {
                switch(this.type) {
                    case 'life':
                        this.game.lives = Math.min(this.game.lives + 1, 5);
                        break;
                    case 'speed':
                        this.game.ball.dx *= 1.2;
                        this.game.ball.dy *= 1.2;
                        break;
                    case 'size':
                        this.game.paddle.width = Math.min(this.game.paddle.width * 1.2, 150);
                        break;
                }
                this.game.soundManager.play('bonus');
            }
        }

        // Клас для платформи
        class Paddle {
            constructor(game) {
                this.game = game;
                this.width = 100;
                this.height = 20;
                this.x = (game.width - this.width) / 2;
                this.y = game.height - this.height - 10;
                this.speed = 8;
                this.dx = 0;
            }

            update() {
                // Оновлення позиції платформи
                this.x += this.dx;

                // Обмеження руху платформи межами canvas
                if (this.x < 0) {
                    this.x = 0;
                }
                if (this.x + this.width > this.game.width) {
                    this.x = this.game.width - this.width;
                }
            }

            draw() {
                this.game.ctx.fillStyle = '#0095DD';
                this.game.ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        // Клас для цеглин
        class Brick {
            constructor(game, x, y, color, type = 'normal') {
                this.game = game;
                this.width = 80;
                this.height = 20;
                this.x = x;
                this.y = y;
                this.color = color;
                this.type = type; // 'normal', 'bonus', 'strong'
                this.status = 1;
                this.hits = type === 'strong' ? 2 : 1;
            }

            draw() {
                if (this.status === 1) {
                    this.game.ctx.fillStyle = this.color;
                    this.game.ctx.fillRect(this.x, this.y, this.width, this.height);
                    this.game.ctx.strokeStyle = '#000';
                    this.game.ctx.strokeRect(this.x, this.y, this.width, this.height);

                    // Відображення додаткової інформації для міцних цеглин
                    if (this.type === 'strong') {
                        this.game.ctx.fillStyle = '#fff';
                        this.game.ctx.font = '12px Arial';
                        this.game.ctx.fillText(this.hits.toString(), 
                            this.x + this.width/2 - 4, this.y + this.height/2 + 4);
                    }
                }
            }

            hit() {
                if (this.type === 'strong') {
                    this.hits--;
                    if (this.hits <= 0) {
                        this.status = 0;
                        this.game.soundManager.play('break');
                        if (Math.random() < 0.3) { // 30% шанс випадання бонусу
                            const bonusType = ['life', 'speed', 'size'][Math.floor(Math.random() * 3)];
                            this.game.bonuses.push(new Bonus(this.game, this.x, this.y, bonusType));
                        }
                    }
                } else {
                    this.status = 0;
                    this.game.soundManager.play('break');
                    if (this.type === 'bonus' && Math.random() < 0.5) { // 50% шанс випадання бонусу
                        const bonusType = ['life', 'speed', 'size'][Math.floor(Math.random() * 3)];
                        this.game.bonuses.push(new Bonus(this.game, this.x, this.y, bonusType));
                    }
                }
            }
        }

        // Клас для м'яча
        class Ball {
            constructor(game) {
                this.game = game;
                this.radius = 10;
                this.x = game.width / 2;
                this.y = game.height - 50;
                this.dx = 4;
                this.dy = -4;
            }

            update() {
                // Оновлення позиції м'яча
                this.x += this.dx;
                this.y += this.dy;

                // Відбиття від стін
                if (this.x + this.radius > this.game.width || this.x - this.radius < 0) {
                    this.dx = -this.dx;
                }
                if (this.y - this.radius < 0) {
                    this.dy = -this.dy;
                }

                // Перевірка зіткнення з платформою
                if (this.y + this.radius > this.game.paddle.y &&
                    this.x > this.game.paddle.x &&
                    this.x < this.game.paddle.x + this.game.paddle.width) {
                    this.dy = -this.dy;
                }

                // Перевірка зіткнення з цеглинами
                for (let brick of this.game.bricks) {
                    if (brick.status === 1) {
                        if (this.x + this.radius > brick.x &&
                            this.x - this.radius < brick.x + brick.width &&
                            this.y + this.radius > brick.y &&
                            this.y - this.radius < brick.y + brick.height) {
                            this.dy = -this.dy;
                            brick.hit();
                            this.game.score += 10;
                            this.game.soundManager.play('hit');
                        }
                    }
                }

                // Перевірка падіння м'яча
                if (this.y + this.radius > this.game.height) {
                    this.game.lives--;
                    this.reset();
                }
            }

            draw() {
                this.game.ctx.beginPath();
                this.game.ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                this.game.ctx.fillStyle = '#0095DD';
                this.game.ctx.fill();
                this.game.ctx.closePath();
            }

            reset() {
                this.x = this.game.width / 2;
                this.y = this.game.height - 50;
                this.dx = 4;
                this.dy = -4;
            }
        }

        // Клас для керування грою
        class Game {
            constructor() {
                this.canvas = canvas;
                this.ctx = ctx;
                this.width = canvas.width;
                this.height = canvas.height;
                this.score = 0;
                this.lives = 3;
                this.isRunning = false;
                this.gameState = 'start'; // 'start', 'playing', 'gameOver'
                this.paddle = new Paddle(this);
                this.ball = new Ball(this);
                this.bricks = [];
                this.bonuses = [];
                this.level = 1;
                this.soundManager = new SoundManager();
                this.initBricks();
                this.initScreens();
            }

            initScreens() {
                this.startScreen = document.getElementById('startScreen');
                this.gameOverScreen = document.getElementById('gameOverScreen');
                this.startButton = document.getElementById('startButton');
                this.restartButton = document.getElementById('restartButton');
                this.finalScore = document.getElementById('finalScore');

                this.startButton.addEventListener('click', () => this.start());
                this.restartButton.addEventListener('click', () => this.restart());
            }

            // Ініціалізація цеглин
            initBricks() {
                const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                const rows = 7;
                const bricksPerRow = 8;
                const brickWidth = 80;
                const brickHeight = 20;
                const padding = 10;
                const offsetTop = 30;
                const offsetLeft = (this.width - (bricksPerRow * (brickWidth + padding))) / 2;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < bricksPerRow; c++) {
                        const x = c * (brickWidth + padding) + offsetLeft;
                        const y = r * (brickHeight + padding) + offsetTop;
                        
                        // Визначення типу цеглини
                        let type = 'normal';
                        if (Math.random() < 0.2) { // 20% шанс бонусної цеглини
                            type = 'bonus';
                        } else if (Math.random() < 0.1) { // 10% шанс міцної цеглини
                            type = 'strong';
                        }

                        this.bricks.push(new Brick(this, x, y, colors[r], type));
                    }
                }
            }

            // Ініціалізація гри
            init() {
                // Додаємо обробники подій для керування платформою
                document.addEventListener('keydown', (e) => {
                    if (this.gameState === 'playing') {
                        if (e.key === 'ArrowLeft' || e.key === 'a') {
                            this.paddle.dx = -this.paddle.speed;
                        }
                        if (e.key === 'ArrowRight' || e.key === 'd') {
                            this.paddle.dx = this.paddle.speed;
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || 
                        e.key === 'a' || e.key === 'd') {
                        this.paddle.dx = 0;
                    }
                });

                // Відображаємо початковий стан
                this.draw();

                // Запускаємо фонову музику
                this.soundManager.playBackgroundMusic();
            }

            // Оновлення стану гри
            update() {
                if (this.gameState === 'playing') {
                    this.paddle.update();
                    this.ball.update();
                    
                    // Оновлення бонусів
                    this.bonuses = this.bonuses.filter(bonus => {
                        bonus.update();
                        return bonus.active;
                    });

                    // Оновлення відображення рахунку та життів
                    document.getElementById('score').textContent = `Очки: ${this.score}`;
                    document.getElementById('lives').textContent = `Життя: ${this.lives}`;

                    // Перевірка перемоги
                    if (this.bricks.every(brick => brick.status === 0)) {
                        this.gameOver(true);
                    }

                    // Перевірка закінчення гри
                    if (this.lives <= 0) {
                        this.gameOver(false);
                    }
                }
            }

            // Відображення гри
            draw() {
                // Очищення canvas
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // Відображення елементів гри
                this.bricks.forEach(brick => brick.draw());
                this.bonuses.forEach(bonus => bonus.draw());
                this.paddle.draw();
                this.ball.draw();
            }

            // Головний цикл гри
            gameLoop() {
                if (this.isRunning) {
                    this.update();
                    this.draw();
                    requestAnimationFrame(() => this.gameLoop());
                }
            }

            // Запуск гри
            start() {
                this.gameState = 'playing';
                this.startScreen.style.display = 'none';
                this.gameOverScreen.style.display = 'none';
                this.isRunning = true;
                this.gameLoop();
            }

            // Зупинка гри
            stop() {
                this.isRunning = false;
                this.soundManager.stopBackgroundMusic();
            }

            // Кінець гри
            gameOver(isWin) {
                this.gameState = 'gameOver';
                this.stop();
                this.finalScore.textContent = `Ваш рахунок: ${this.score}`;
                this.gameOverScreen.style.display = 'flex';
                this.soundManager.play(isWin ? 'win' : 'gameOver');
            }

            // Перезапуск гри
            restart() {
                this.score = 0;
                this.lives = 3;
                this.bricks = [];
                this.bonuses = [];
                this.level = 1;
                this.initBricks();
                this.ball.reset();
                this.paddle.width = 100;
                this.paddle.x = (this.width - this.paddle.width) / 2;
                this.start();
                this.soundManager.playBackgroundMusic();
            }
        }

        // Створюємо екземпляр гри
        const game = new Game();

        // Ініціалізуємо гру при завантаженні сторінки
        window.addEventListener('load', () => {
            game.init();
        });
    </script>
</body>
</html> 
